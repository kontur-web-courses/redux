<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="reveal/css/reveal.css">
    <link rel="stylesheet" href="reveal/css/theme/kontur-light.css" id="theme">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="reveal/css/highlight/idea-for-light.css">
    <link rel="stylesheet" href="reveal/css/highlight/darkula-for-dark.css">
    <!--[if lt IE 9]>
    <script src="reveal/js/html5shiv.js"></script>
    <![endif]-->
	<script defer src="reveal/js/head.min.js"></script>
	<script defer src="reveal/js/reveal.js"></script>
	<script defer src="reveal/initialize.js"></script>
	<script defer src="reveal/js/d3.min.js"></script>

	<style>
		.fragment-container {
			position: relative;
		}
		
		.fragment-container .fragment {
			position: absolute;
			top: 0px;
			width: 100%;
		}

		.tools.tools {
			margin: -30% auto 0;
			height: 100vh;
			display: block;
		}
		
		.slides .center {
			text-align: center;
		}

		.slides .comparison {
			display: flex;
			justify-content: space-between
		}
	</style>
	
	<title>Redux</title>
</head>
<body>

<div class="reveal"><div class="slides">

<section data-markdown><script type="text/template">

# Redux

<p class="center"><a href="https://github.com/kontur-web-courses/redux">https://github.com/kontur-web-courses/<b>redux</b></a></p>

</script></section>

<section data-markdown><script type="text/template">

## Сначала самое ~~долгое~~ важное

Скачиваем все необходимые пакеты Node.js:
```
cd tasks
npm ci
```

Затем запусти dev-сервер, чтобы видеть результаты решений заданий:
```cmd
npm start
```

Посмотреть можно будет на <a href="http://localhost:8080">http://localhost:8080</a>

Перестроение автоматическое, пока работает dev-сервер

***

### Расположение заданий и примеров

Для выполнения заданий папку `/tasks` надо
открыть в редакторе кода

В презентации пути указаны от папки: `/tasks/src`

Расположение заданий:
- Папка заданий: `~/{#.Папка}/`
- Примеры: `~/{#.Папка}/samples/`
- Формулировка задания: `~/{#.Папка}/{#.ИмяЗадания}.md`

</script></section>


<!-- ************************************************* -->


<section data-markdown><script type="text/template">

## 1. Единый state приложения

***

### Lifting state ~~up~~ out

<img src="assets/redux-state.png">

Мотивация:
- Несколько компонентов зависят от одних данных
- Взаимодействующие компоненты в разных частях дерева

***

### Три принципа Redux

1. Единственный источник правды
2. Состояние доступно только на чтение
3. Изменения вносятся чистыми функциями

Мотивация:
- Контроль целостности в больших приложениях
- Изменения состояния можно протестировать модульно

> *Неизменяемый объект (immutable object)* — объект, состояние которого не может быть изменено после создания.
> *Чистая функция (pure function)* — это функция без побочных эффектов, ее результат полностью определяется аргументами

***

### Как вытащить состояние из компонентов?

***

### Цикл изменения состояния компонента

<img width="600px" src="assets/react-cycle.png">

***

### Цикл изменения состояния в Redux

<img width="600px" src="assets/redux-cycle.png">

***

### Выделим состояние простого приложения

<div class="center"><img width="300px" src="assets/sandglass-start.png"></div>

***

### Код главного компонента

```js
class App extends React.Component {
  state = { seconds: 15 };

  handleDecrease = () => {
    this.setState(prevState => ({ seconds: prevState.seconds - 1 }));
  };
  handleIncrease = () => {
    this.setState(prevState => ({ seconds: prevState.seconds + 1 }));
  };

  render() {
    return (<Timer seconds={this.state.seconds}
      onDecrease={this.handleDecrease} onIncrease={this.handleIncrease}/>
    );
  }
}
```

Код полностью: `~/1.Sandglass/samples/sample1.component.js`

***

### Важен код, в котором меняется состояние

```js
class App extends React.Component {
  state = { seconds: 15 }; // задается начальное состояние

  handleDecrease = () => {
    // состояние меняется
    this.setState(prevState => ({ seconds: prevState.seconds - 1 }));
  };
  handleIncrease = () => {
    // состояние меняется
    this.setState(prevState => ({ seconds: prevState.seconds + 1 }));
  };
  ...
}
```

***

### dispatch

Выделим код, в котором меняется состояние
в отдельную функцию, назовем ее `dispatch`

```js
class App extends React.Component {
  state = { seconds: 15 }; // задается начальное состояние

  dispatch(action) {
    // состояние меняется
    this.setState(prevState => prevState.seconds + action.value);
  }

  handleDecrease = () => this.dispatch({ value: -1 });
  handleIncrease = () => this.dispatch({ value: 1 });
  ...
}
```

Теперь все изменения происходят в одном месте

***

### Reducer

Это чистая функция, которая:
- создает начальное состояние
- определяет как обновляется состояние

***

### Выделим обновление состояния в reducer

```js
// Обновление состояния в dispatch:
this.setState(prevState => prevState.seconds + action.value); // до
this.setState(prevState => timerReducer(prevState, action)); // после

// Задание начального состояния:
state = { seconds: 15 }; // до
state = timerReducer(undefined, {}); // после

// Тогда структура reducer:
const timerReducer = (state, action) => {
    ...
	return newState;
};
```

***

### Тогда код reducer

```js
const timerReducer = (state = { seconds: 15 }, action) => {
  switch (action.type) {
    case 'CHANGE_SECONDS':
      return { seconds: state.seconds + action.value };
    default:
      return state;
  }
};
```

***

### Создание начального состояния
Состояние инициализируется за счет значения по умолчанию аргумента `state` и возвращается в ветке `default`,
ведь `action = {}`:
```js
const timerReducer = (state = { seconds: 15 }, ...) => {
  ...
    default:
      return state;
  ...
}
```

***

### Обновление состояния
Reducer обязан вернуть актуальное состояние:
1. Если `action` не влияет на состояние, то должно вернуться старое
2. Но если `action` должен повлиять на состояние, то создается и возвращается новый объект состояния с необходимыми изменениями. Старый объект состояния не меняется
```js
    case 'CHANGE_SECONDS':
      return { seconds: state.seconds + action.value };
    default:
      return state;
```

***

### Реагирование на разные действия

Строка `action.type` позволяет обрабатывать разные действия, изменяющие состояние

```js
   switch (action.type) {
     case 'CHANGE_SECONDS': ...
     default: ...
  }
```

***

### Чистота и иммутабельность

```js
const timerReducer = (state = { seconds: 15 }, action) => {
  switch (action.type) {
    case 'CHANGE_SECONDS':
      return { seconds: state.seconds + action.value };
    default:
      return state;
  }
}
```

Возвращаемое reducer состояние  зависит только от передаваемых аргументов, поэтому reducer — *чистая функция*.

Reducer при изменениях создает новое состояние, таким образом состояние доступно только на чтение и удовлетворяет паттерну *immutable object*.

***

### Использование reducer

```js
class App extends React.Component {
  state = timerReducer(undefined, {}); // задается начальное состояние

  dispatch(action) {
    // состояние меняется
    this.setState(prevState => timerReducer(prevState, action));
  }

  handleDecrease = () => this.dispatch({ type: 'CHANGE_SECONDS', value: -1 });
  handleIncrease = () => this.dispatch({ type: 'CHANGE_SECONDS', value: 1 });
  ...
}
```

Код полностью: `~/1.Sandglass/samples/sample2.reducer.js`

***

### Отделим состояние приложения от React
1. `state` переносится за пределы компонента
2. Взаимодействие с объектом `state` скрывается
за обертку `store` с набором допустимых методов
3. `reducer`, определяющий правила изменения `state`
уже находится вне компонента!

***

### Store

Сущность, которая содержит методы:
- `getState` для получения текущего состояния
- `dispatch` для обработки изменений состояния
- `subscribe` для подписки на изменения состояния

Будем создавать с помощью специальной функции:
```js
const store = createStore(reducer);
```

***

### Получение состояния

```js
const createStore = reducer => {
  let state;

  const getState = () => state;

  return { getState };
};
```

***

### Обработка изменений

```js
const createStore = reducer => {
  let state;

  const getState = () => state;

  const dispatch = action => {
    // состояние меняется
    state = reducer(state, action);
  };

  dispatch({}); // задается начальное состояние

  return { getState, dispatch };
};
```

***

### Подписка на изменения

```js
const createStore = reducer => {
  let listeners = [];
  ...
  const dispatch = action => {
    state = reducer(state, action);
    // все подписчики уведомляются сразу после изменения состояния
    listeners.forEach(listener => listener());
  };
  const subscribe = listener => {
    listeners.push(listener);
    // функция отписки
    return () => { listeners = listeners.filter(item => item !== listener); };
  };
  ...
  return { getState, dispatch, subscribe };
};
```

***

### Передача store в React

```js
const appStore = createStore(timerReducer);

ReactDom.render(<App store={appStore} />, document.getElementById('app'));
```

***

### Получение состояния

```js
class App extends React.Component {
  // начальное состояние просто берется из store
  state = this.props.store.getState();
  ...
}
```

***

### Обработка изменений

```js
class App extends React.Component {
  ...
  handleDecrease = () =>
    this.props.store.dispatch({ type: 'CHANGE_SECONDS', value: -1 });
  handleIncrease = () =>
    this.props.store.dispatch({ type: 'CHANGE_SECONDS', value: 1 });
  ...
}
```

***

### Подписка на изменения

```js
class App extends React.Component {
  ...
  componentDidMount() {
    this.props.store.subscribe(() => {
      // задается новое состояние компонента и происходит перерисовка
      this.setState(this.props.store.getState());
    });
  }
  ...
}
```

***

### Отписка от изменений

```js
class App extends React.Component {
  ...
  componentDidMount() {
    // subscribe возвращает функцию для отписки
    this.unsubscribe = this.props.store.subscribe(() => {
      this.setState(this.props.store.getState());
    });
  }
  componentWillUnmount() {
    // при удалении компонента можно отписаться
    this.unsubscribe && this.unsubscribe();
  }
  ...
}
```

***

Код полностью: `~/1.Sandglass/samples/sample3.store.js`

***

### Redux без React

Идея Redux о едином месте хранения состояния,
которое обновляется чистыми функциями, не привязана к React

Redux требуется только функция render,
чтобы отрисовывать view при изменении состояния

Эту функцию можно реализовать на DOM API

***

### Только функция render

```js
const appStore = createStore(timerReducer);
const handleDecrease = () =>
  appStore.dispatch({ type: 'CHANGE_SECONDS', value: -1 });
const handleIncrease = () =>
  appStore.dispatch({ type: 'CHANGE_SECONDS', value: 1 });
  
const render = () => {
  // React используется для отрисовки, но не отвечает за перерисовку
  ReactDom.render(
    (<Timer seconds={appStore.getState().seconds}
      onDecrease={handleDecrease} onIncrease={handleIncrease}/>),
    document.getElementById('app'));
}

appStore.subscribe(render); // перерисовка при изменениях
render(); // первоначальная отрисовка
```

Код полностью: `~/1.Sandglass/samples/sample4.render.js`

***

### Создание действий

```js
// action, действие
{ type: 'CHANGE_SECONDS', value }

// action creator, создатель действий
const changeSeconds = (value) => ({
  type: 'CHANGE_SECONDS',
  value
});

// позволяет использовать автодополнение при создании action
changeSeconds(5);
```

***

### Действия с payload

Параметры `action` часто объединяются
в один объект с ключом `payload`

```js
const changeSeconds = value => ({
  type: 'CHANGE_SECONDS',
  value // обычный вариант
});

const changeTime = (hour, minute, second) => ({
  type: 'CHANGE_TIME',
  payload: { // несколько параметров объединены
    hour,
    minute,
    second
  }
});
```

***

### Обработка payload

```js
const timerReducer = (state = { seconds: 15 }, action) => {
  switch (action.type) {
    case 'CHANGE_SECONDS':
      return { seconds: state.seconds + action.value };
    case 'CHANGE_TIME':
      // передаем payload для обработки в другую функцию
      return { seconds: state.seconds + getTotalSeconds(action.payload) };
    default:
      return state;
  }
};

const getTotalSeconds = ({ hour, minute, second }) => {
  return (hour * 60 + minute) * 60 + second;
};
```

***

### Унифицированная обработка payload

При унификации можно сделать деструктуризацию сразу,
а в функции-обработчики передавать `payload`, а не весь `action`
```js
const changeSeconds = (state, { value }) => ({
  seconds: state.seconds + value
});
const changeTime = (state, { hour, minute, second }) => ({
  seconds: state.seconds + (hour * 60 + minute) * 60 + second
});
export const timerReducer = (state = { seconds: 15 }, { type, payload }) => {
  switch (type) {
    case 'CHANGE_SECONDS':
      return changeSeconds(state, payload);
    case 'CHANGE_TIME':
      return changeTime(state, payload);
    default:
      return state;
  }
};
```

Код полностью: `~/1.Sandglass/samples/sample5.payload.js`

***

### Типы действий повторяются

```js
const changeSeconds = value => ({
  type: 'CHANGE_SECONDS',
  value
});

const timerReducer = (state = { seconds: 15 }, action) => {
  switch (action.type) {
    case 'CHANGE_SECONDS':
      return { seconds: state.seconds + action.value };
    default:
      return state;
  }
};
```

Легко сделать опечатку и код не будет работать!

***

### Выделение константы для типа действия

```js
const CHANGE_SECONDS = 'CHANGE_SECONDS';

const changeSeconds = value => ({
  type: CHANGE_SECONDS,
  value
});

const timerReducer = (state = { seconds: 15 }, action) => {
  switch (action.type) {
    case CHANGE_SECONDS:
      return { seconds: state.seconds + action.value };
    default:
      return state;
  }
};
```

Не обязательно для маленьких приложений, полезно в больших

Код полностью: `~/1.Sandglass/samples/sample6.action.js`

***

### Разделение по файлам

```js
// timerActionTypes.js
export const CHANGE_SECONDS = 'CHANGE_SECONDS';
```

```js
// timerActionCreators.js
import * as timerActionTypes from './timerActionTypes.js';
export const changeSeconds = value =>
  ({ type: timerActionTypes.CHANGE_SECONDS, value });
```

```js
// timerReducer.js
import * as timerActionTypes from './timerActionTypes.js';
export const timerReducer = (state = { seconds: 15 }, action) => {
  switch (action.type) {
    case timerConstants.CHANGE_SECONDS:
      return { seconds: state.seconds + action.value };
    ...
  }
}
```

Полезно для больших приложений с множеством reducer'ов

Код полностью: `~/1.Sandglass/samples/sample7.separated/`

***

### Переизобрели Redux

<img width="600px" src="assets/redux-cycle.png">

***

### Задание 1. Sandglass

***

### Выводы

1. Единственный источник правды
*store*
2. Состояние доступно только на чтение
*immutable state*
3. Изменения вносятся чистыми функциями
*reducer*

Корректность reducer можно проверять модульными тестами

***

Структура состояния приложения НЕ совпадает со структурой компонентов:
- Структура состояния определяется **предметной областью** и **идеей приложения**, а структура компонентов ее представлением
- Одна и та же часть состояния может использоваться многими компонентами
*как это делают Timer и Sandglass*
- Проектирование состояния вместе с написанием reducer
и создание компонентов для визуализации — две разные задачи
*reducer был полностью написан и протестирован, а уже затем подключен к визуальной части*

***

Связь `actions` и `reducer` через `dispatch` является слабой,
что открывает следующие возможности:
- Разные события меняют одну и ту же часть состояния
*changeSeconds и restart*
- Изменения состояния порождаются в разных частях приложения
*кнопки в Timer, кнопка для restart*
- Изменения состояния порождаются событиями вне React
*setInterval*
- Одно событие порождает изменения в разных частях состояния
*встретится далее*

***

### Redux — это компромисс

<img src="assets/not-need-redux.png">

С *Redux* будет больше кода,
но это оправдано для *больших приложений*,
которые пишут *большие команды*.

</script></section>


<!-- ************************************************* -->


<section data-markdown><script type="text/template">

## 2.1. Redux для React
<div class="center">с провайдером и коннектом</div>

***

### Передача store

Легко передать store в корневой компонент

```js
const appStore = createStore(reducer);

ReactDom.render(<App store={appStore} />, document.getElementById('app'));
```

Чтобы передать глубже придется пробрасывать через props?!

***

### Передача через Context

<img width="300px" src="assets/context.png">

Context может передать store на нужный уровень

***

### Идея передачи через Context

```js
const Context = React.createContext();
const store = createStore(reducer);

//App.js
render() { // передаем store в контекст
  return (<Context.Provider value={store}>
            <RootComponent />
          </Context.Provider>);
}
//Wrapper.js
render() { // получаем store в компоненте-обертке и передаем во WrappedComponent
  return (<Context.Consumer>
	        value => <WrappedComponent store={value} />
	      </Context.Consumer>);
}
```

***

### Нюансы передачи через Context

1. Компонент-провайдер должен **подписаться** на store,
   чтобы уведомлять консьюмеров
2. Писать каждый раз логику Wrapper неудобно,
   нужен **High Order Component**
3. Оборачиваемый компонент не зависит от всего состояния,
   значит надо **передавать только нужные части состояния**
4. Компонент-провайдер следит за всеми изменениями store,
   но оборачиваемые компоненты должны обновляться только
   **при изменениях используемых частей состояния**

***

### Желаемое использование Provider

```js
//App.js
function App({store}) {
  return (
    <Provider store={store}>
      <RootComponent />
    </Provider>
  );
}
```

***

### Желаемое использование HOC

```js
// Настройка связи со store
const withStore = connect(
  (state, props) => ({
    seconds: state.seconds
  }),
  (dispatch, props) => ({
    onChange: value => dispatch(changeSeconds(value))
  })
);

// Создание компонента
const ConnectedTimer = withStore(Timer);
```
`connect` — это High Order Function,
порождающая High Order Component

***

### Все уж готово

Реализовывать `Provider` и `connect()` самостоятельно не нужно!

Их можно взять из пакета `react-redux`

***

### Размещение компонентов

`connect` порождает новые компоненты из обычных
Где и как их разместить в проекте?

***

### Размещать будем в отдельной папке!

***

### Presentational and Container Components

При организации приложения можно разделять все компоненты на
- *presentational* — отвечающие только за отображение
- *container* — отвечающие за связь со store

***

### Presentational Components

Отвечают за то, как все **выглядит**

Могут содержать **разметку и стили**
Не определяют как данные загружаются или изменяются
Принимают данные и callbacks **только через props**
Часто получают содержимое через props.children

Если имеют собственное состояние,
то это скорее **состояние UI**, чем данные

**Могут использовать presentational и container компоненты**

*Примеры: Page, Sidebar, Loader, UserInfo, List*

***

### Container Components

Отвечают за то, как все **работает**

Никогда не содержат стили, разметка только для компоновки
**Обеспечивают данными и «поведением»** другие компоненты

Обычно создаются **через Higher Order Components**,
например `connect()` из Redux, `createContainer()` из Relay

**Могут использовать presentational и container компоненты**

*Примеры: UserPage, FollowersSidebar, FollowedUserList*

***

### Преимущества разделения
- Лучшее разделение ответственности. Проще понимать код.
  Можно разрабатывать логику и отображение независимо.
- Лучшее переиспользование presentational компонентов
- Presentational компоненты — это «палитра» приложения,
  можно сделать демо-страницу со всеми возможными видами для дизайнера
  *С этим поможет [Storybook](https://storybook.js.org/)*

***

### Задание 2.1. Navigation

***

### Выводы
1. Компонент легко **подключается** к store
вне зависимости от своего положения в дереве компонентов
2. Компонент может **влиять** на любые другие компоненты
через store (Navigation на Pages)
3. Компоненты удобно разделить
на **presentational**, которые получают информацию из props,
и **containers**, которые взаимодействуют со store

</script></section>


<!-- ************************************************* -->


<!-- ************************************************* -->


<section data-markdown><script type="text/template">

## 2.2. Middleware

***

### Обычный dispatch

<img width="600px" src="assets/middleware0.png">

***

### dispatch с middleware

<img width="600px" src="assets/middleware1.png">

*Middleware* — промежуточный слой

`dispatch` оборачивается другой функцией
и в обертке кладется в `store`

***

### Логирование

<img width="600px" src="assets/middleware-log.png">

***

### Измерение производительности

<img width="600px" src="assets/middleware-measure.png">

***

### Фильтрация по условию

<img width="600px" src="assets/middleware-filter.png">

***

### Вызов переданной функции

<img width="600px" src="assets/middleware-call.png">

***

### Простейшее middleware

```js
const customMiddleWare = ({ getState, dispatch }) => next => action => {
  return next(action);
};
```

1. `{ getState, dispatch }` передается при подключении к `store`
2. `next` обеспечивает композицию,
содержит базовый `dispatch` или следующий `middleware`
3. `action` — действие, которое надо обработать

***

### Более сложный пример

```js
// Отправляет отчеты об ошибках когда обновляется
// состояние и уведомляются слушатели.
const crashReporter = ({ getState, dispatch }) => next => action => {
  try {
    return next(action)
  } catch (err) {
    console.error('Caught an exception!', err)
    // Можно отправить логи на сервер
    throw err
  }
}
```

***

### Подключение middleware

```js
const store = createStore(
  rootReducer,
  applyMiddleware(middleware)
);
```

`applyMiddleware` — функция из `redux`

***

### Задание 2.2. Logging

***

### Композиция middleware

<img width="600px" src="assets/middleware-compose1.png">

***

### Каждый middleware вызывает next

<img width="600px" src="assets/middleware-compose2.png">

***

### Каждому middleware доступно API от store

<img width="600px" src="assets/middleware-compose3.png">

***

### Подключение нескольких middleware

```js
const store = createStore(
  rootReducer,
  applyMiddleware(middleware1, middleware2, middleware3)
);
```

`action` будет проходить `middleware` в порядке 1, 2, 3
А результат будет выходить в порядке 3, 2, 1

`applyMiddleware` — функция из `redux`

***

### Выводы

**Middleware — точка расширения для Redux**

Позволяет:
- Добавлять новые фичи в обработку действий
- Логировать все действия без модификации кода приложения
- и так далее

Middleware для многих задач уже написаны
А если нужно что-то специфическое — **легко написать свое!**

</script></section>


<section data-markdown><script type="text/template">

## 2.3. Коллекции

***

### Хранение сущностей в массиве

```js
const state = {
  products: [
    { id: 1, name: "Яблоко" },
	{ id: 2, name: "Апельсин" },
	{ id: 3, name: "Виноград" }
  ]
}
```

Возможный вариант, но что если...

***

### Нужно показывать выбранный элемент?

```js
const state = {
  products: [
    { id: 1, name: "Яблоко" },
	{ id: 2, name: "Апельсин" },
	{ id: 3, name: "Виноград" }
  ],
  currentProduct: { id: 2, name: "Апельсин" }
}
```
В диалоговом окне показывается подробная информация
о выбранном продукте

***

### Входит в состав другой сущности?

```js
const state = {
  products: [
    { id: 1, name: "Яблоко" },
	{ id: 2, name: "Апельсин" },
	{ id: 3, name: "Виноград" }
  ],
  purchases: [
	{ product: { id: 2, name: "Апельсин" }, quantity: 3}
  ]
}
```

При отображении покупки в интернет-магазине
надо показывать название продукта

***

### Нужно показывать выборку?

```js
const state = {
  products: [
    { id: 1, name: "Яблоко" },
	{ id: 2, name: "Апельсин" },
	{ id: 3, name: "Виноград" }
  ],
  chosenProducts: [
    { id: 1, name: "Яблоко" },
    { id: 2, name: "Апельсин" }
  ]
}
```

Пользователь добавил фильтр и временно надо показывать
только подходящие продукты

***

### Получаем перерасход памяти

```js
const state = {
  products: [
    { id: 1, name: "Яблоко" },
	{ id: 2, name: "Апельсин" },
	{ id: 3, name: "Виноград" }
  ],
  currentProduct: { id: 2, name: "Апельсин" },
  purchases: [
	{ product: { id: 2, name: "Апельсин" }, quantity: 3}
  ],
  chosenProducts: [
    { id: 1, name: "Яблоко" },
    { id: 2, name: "Апельсин" }
  ]
}
```

***

### При изменении нужно обновлять везде
```js
const state = {
  products: [
    { id: 1, name: "Яблоко" },
	{ id: 2, name: "МАНДАРИН" },
	{ id: 3, name: "Виноград" }
  ],
  currentProduct: { id: 2, name: "МАНДАРИН" },
  purchases: [
	{ product: { id: 2, name: "Апельсин" }, quantity: 3}
  ],
  chosenProducts: [
    { id: 1, name: "Яблоко" },
    { id: 2, name: "Апельсин" }
  ]
}
```

Изменили в диалоговом окне — мало обновить
исходную коллекцию

***

### Можно использовать идентификаторы

```js
const state = {
  products: [
    { id: 1, name: "Яблоко" },
	{ id: 2, name: "МАНДАРИН" },
	{ id: 3, name: "Виноград" }
  ],
  currentProductId: 2,
  purchases: [
	{ productId: 2, quantity: 3}
  ],
  chosenProductIds: [1, 2]
}
```

Лучше, но поиск по id в массиве продуктов неэффективен...

***

### Коллекция

```js
const state = {
  products: {
    allIds: [1, 2, 3],
	byId: {
	  1: { id: 1, name: "Яблоко" },
	  2: { id: 2, name: "МАНДАРИН" },
	  3: { id: 3, name: "Виноград" }
	}
  },
  currentProductId: 2,
  purchases: [
	{ productId: 2, quantity: 3}
  ],
  chosenProductIds: [1, 2]
}
```

Храним отдельно все идентификаторы и сами объекты

- Удобно изменять локально и обновлять с сервера
- Нет лишних данных

***

### Задание 2.3. Menu

***

### Выводы
1. Коллекция позволяет подключать контейнер по идентификатору: все необходимые компоненту данные контейнер достанет из `byId`
2. Компоненту, отображающему список контейнеров,
достаточно знать список идентификаторов

</script></section>


<!-- ************************************************* -->


<section data-markdown><script type="text/template">

## 2.4. Взаимодействие с API

***

### Действия при запросах

```js
function load() {
  // 1. Перед запросом
  api
    .fetchData()
    .then(data => {
      // 2. После запроса
    })
    .catch(reason => {
      // 3. Если что-то пошло не так
    });
}
```

Всегда есть три шага:
1. Показать, что загрузка началась, например, показать лоадер
2. Добавить данные, убрать лоадер, показать результат
3. Обработать ошибку, убрать лоадер, сообщить пользователю

***

### Версия с async/await

```js
async function loadAsync() {
  // 1. Перед запросом
  try {
    const data = await api.fetchData();
    // 2. После запроса
  } catch (error) {
    // 3. Если что-то пошло не так
  }
}
```

Всегда есть три шага:
1. Показать, что загрузка началась, например, показать лоадер
2. Добавить данные, убрать лоадер, показать результат
3. Обработать ошибку, убрать лоадер, сообщить пользователю

***

### Три действия

Всегда есть три шага,
значит надо три раза изменять state
с помощью трех действий

```js
// 1. Перед запросом
export const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST';
// 2. После запроса
export const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS';
// 3. Если что-то пошло не так
export const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE';
```

Часто названиях их типов отличаются только последним словом,
чтобы указать, что они относятся к одному запросу

***

### case-функции

```js
const changeSeconds = (state, { value }) => ({ seconds: state.seconds + value });
const restart = (state, action) => ({ seconds: 15; });

const reducer = (state, action) => {
  switch (action.type) {
    case CHANGE_SECONDS:
      return changeSeconds(state, action);
    case RESTART:
      return restart(state, action);
    default:
      return state;
  }
};

```

Обработка каждого типа действия может быть большой,
поэтому часто обработку конкретного действия переносят
в отдельную функцию, case-функцию

***

### Задание 2.4. Api

***

### Выводы
1. Запросы на сервер могут привести к трем изменениям в store
2. Обработка действий в case-функциях упрощяет редьюсер


</script></section>


<!-- ************************************************* -->


<section data-markdown><script type="text/template">

## 2.5. Организация редьюсеров

***

### Слайсы

Будем называть *слайсом* часть состояния, которая является значением этого состояния для некоторого ключа

```js
const state = {
  page: 'menu',
  products: [{ id: 1, name: 'Блюдо' }]
};
```

В примере `page` — это один слайс, а `products` — это другой слайс

***

### Разделение действий по слайсам

```js
const rootReducer = (state = {}, action) => {
  switch (action.type) {
    case actionTypes.NAVIGATE_TO_PAGE:
      return { ...state, page: action.page };
    case actionTypes.LOAD_PRODUCTS:
      return { ...state, products: action.products};
  }
  return state;
}
```

Действия обычно меняют только один слайс,
поэтому можно их разделить по слайсам.

Здесь `NAVIGATE_TO_PAGE` меняет слайс `page`,
а `LOAD_PRODUCTS` меняет слайс `products`.

***

### Разделение обработки слайсов

```js
const pageReducer = (state = Page.menu, action) => {
  return action.type === actionTypes.NAVIGATE_TO_PAGE ? action.page : state;
};
const productsReducer = (state = [], action) => {
  return action.type === actionTypes.LOAD_PRODUCTS ? action.products : state;
};

const rootReducer = (state = {}, action) => {
  return {
    page: pageReducer(state.page, action),
    products: productsReducer(state.products, action)
  };
}
```

Каждый slice-редьюсер отвечает только за один кусочек состояния.
А `rootReducer` собирает его полностью.

***

### combineReducers

```js
const rootReducer = combineReducers(
  {
    page: pageReducer,
    products: productsReducer
  }
);
```

Можно написать функцию `combineReducers`,
которая упростит объединение slice-редьюсеров

***

### Реализация combineReducers

```js
const combineReducers = reducers => {
  return (state = {}, action) => {
    return Object.keys(reducers).reduce((nextState, key) => {
      nextState[key] = reducers[key](state[key], action);
      return nextState;
    }, {});
  };
};
```

`combineReducers` уже написан в `redux`

***

### createReducer

```js
const pageReducer = createReducer(Page.menu, {
  [actionTypes.NAVIGATE_TO_PAGE]: (state, action) => action.page
});

const productsReducer = createReducer([], {
  [actionTypes.LOAD_PRODUCTS]: loadProducts
});
```

Вместо switch можно использовать объект
с обработчиками в качестве значений

Можно написать функцию `createReducer`,
которая упростит создание редьюсеров в таком стиле

***

### Реализация createReducer

```js
function createReducer(initialState, handlers) {
  return function reducer(state = initialState, action) {
    if (handlers.hasOwnProperty(action.type)) {
      return handlers[action.type](state, action);
    } else {
      return state;
    }
  };
}
```

`createReducer` уже написан в пакете `redux-create-reducer`

***

### Задание 2.5. Refactoring

***

### Выводы
1. `combineReducers` позволяет обрабатывать слайсы
в отдельных редьюсерах
2. В slice-редьюсерах **проще обновлять состояние**,
ведь вложенность меньше на один уровень
3. Как следствие, при проектировании состояния приложения
надо стремиться к **более плоской структуре состояния**,
к большему числу независимых слайсов
4. `createReducer` и case-функции отлично подходят
для создания редьюсеров

</script></section>


<!-- ************************************************* -->


<section data-markdown><script type="text/template">

## 2.6. Immutability

***

### Mutable vs Immutable

```js
const person = {
  names: { surname: 'Ace', name: 'Frederic' },
  age: 26
};

// мутирующее обновление: изменения происходят в исходном объекте
person.age = 28;

// немутирующее обновление: создается копия всех измененных частей
const reagedPerson = { ...person, age: 27 };
// а значит person.names переиспользуется
```

***

### Зачем это нужно?

1. ?
2. ?

***

### Пункт 1

Обновление не ломает существующие объекты и компоненты:
- кто в курсе используют новое **согласованное состояние**
- кто не в курсе используют старое **согласованное состояние**

***

### Пункт 2

При обновлении внутри меняется родитель
<img width="800px" src="assets/immutable1.png">
<img width="800px" src="assets/immutable2.png">
Значит **совпадение ссылок гарантирует неизменность!**

***

### Как это делать?

***

### Простой случай

```js
const person = {
  names: { surname: 'Ace', name: 'Frederic' },
  age: 26
};

const reagedPerson = { ...person, age: 27 };
```

Действительно просто!

***

### Обновление вложенного  значения

```js
const person = {
  names: { surname: 'Ace', name: 'Frederic' },
  age: 26
};

// немутирующее обновление вложенного значения
const renamedPerson = {
  ...person,
  names: {
    ...person.names,
    surname: 'Potter'
  }
};
```
Более многословно, чем хотелось бы

***

### Обновление элемента массива

```js
const people = [
  { names: { surname: 'Westlake', name: 'Ronald' }, age: 42 },
  { names: { surname: 'Ace', name: 'Frederic' }, age: 26 }
];

const updatedPeople = people.map((person, index) =>
  index !== 1
    ? person
    : {
        ...person,
        age: 27
      }
);
```
Еще более многословно...

***

### Обновление вложенного значения элемента массива?! 0_o

***

### Можно попробовать пошагово...

```js
const person = people[1];
const renamedPerson = {
  ...person,
  names: {
    ...person.names,
    surname: 'Potter'
  }
};

const updatedPeople = people.map((person, index) =>
  index !== 1 ? person : renamedPerson
);
```

***

### Как обновлять без боли?

1. Избегать объектов с сильно вложенными значениями
В частности: `combineReducers`
2. Обновлять в несколько шагов
3. Написать вспомогательные функции
Примеры: `~/2.Sushi/samples/immutable-updates/`
4. Использовать сторонние библиотеки

***

### Примеры вставки и удаления

```js
function insertItem(array, index, item) {
  return [
    ...array.slice(0, index),
    item,
    ...array.slice(index)
  ];
}

function removeItem(array, index) {
  return array.filter((item, i) => i !== index);
}
```

```js
const peopleWithNewOne = insertItem(people, 3, newPerson);
const peopleWithoutSecond = removeItem(people, 2);
```

***

### Пример обновления по значению

```js
function updateItem(array, index, item) {
  return array.map((oldItem, i) => {
    if (i !== index) {
      return oldItem;
    }
    return {
      ...oldItem,
      ...item
    };
  });
}
```

```js
const peopleWithReaged = updateItem(people, 3, { age: 27 });
```

***

### Пример обновления с callback

```js
function updateItemByIndex(array, index, updateCallback) {
  return array.map((oldItem, i) => {
    if (i !== index) {
      return oldItem;
    }
    return updateCallback(oldItem);
  });
}
```

```js
const peopleWithUpdated = updateItemByIndex(people, 3, person => ({
  ...person,
  age: 27,
  names: {
    ...person.names,
    surname: 'Potter'
  }
}));
```

Callback позволяет продолжать обновление вглубь

***

### В итоге immutable — не больно!

***

### Задание 2.6. TangledFilter

***

### Выводы
1. Обновлять состояние нужно в **immutable-стиле**,
используя средства языка, либо специальные функции,
иначе работать не будет
2. Идеология Redux делает обновление нескольких компонентов, зависящих от одного значения, тривиальным

</script></section>


<!-- ************************************************* -->


<section data-markdown><script type="text/template">

## 2.7. Thunk

***

### Происхождение термина

Вместо значения можно передать в качестве параметра функцию, которая возвращает это значение при вызове

```js
// обычное значение
print(5 + 3);

// функция, возвращающая значение
print(() => 5 + 3);
```
Тогда, если значение не понадобится, его можно не вычислять

Можно сказать, что **значение было «задумано»**, но не посчитано

«Задумано» — «thought», 3-форма неправильного глагола «think»
В шутку или заведомо неправильно говорят «thunk»

**thunk** — это функция без параметров, которая вычисляет и возвращает значение

***

### Thunk Middleware в Redux

<img width="400px" src="assets/middleware-call.png">

Вместо `action` в `dispatch` передается функция,
которая при своем вызове будет вызывать `dispatch`
с нужными ей действиями

***

### Создатель действий для thunk

```js
// Action creator, создающий thunk
const sumAndChange = (a, b) => (dispatch, getState, extraArgument) => {
  dispatch({ type: 'CHANGE_VALUE', value: a + b });
}

// Dispatching с использованием action creator
dispatch(sumAndChange(3, 2));

// Thunk, который будет передан в dispatch со значениями из замыкания
const thunk = (dispatch, getState, extraArgument) => {
  dispatch({ type: 'CHANGE_VALUE', value: 3 + 2 });
};
```

***

### Реализация redux-thunk

```js
function createThunkMiddleware(extraArgument) {
  return ({ dispatch, getState }) => next => action => {
    if (typeof action === 'function') {
      return action(dispatch, getState, extraArgument);
    }
    return next(action);
  };
}
const thunk = createThunkMiddleware(); // версия без extraArgument
thunk.withExtraArgument = createThunkMiddleware; // для версии с extraArgument
export default thunk;
```

Нужен `dispatch` и он доступен

`dispatch` с `thunkMiddleware` возвращает результат
вызова функции, а не `action`, как делает обычный `dispatch`

Можно передать произвольное API через `extraArgument`

***

### Задание 2.7. UnstableFilter

***

### Выводы

**Thunk Middleware** позволяет:

- **Группировать вызовы** нескольких связанных действий
в одну функцию. Например, для выполнения запросов
- **Использовать Promise** в качестве возвращаемого значения
и дожидаться результата
- Передавать **произвольное API**

</script></section>


<!-- ************************************************* -->


<section data-markdown><script type="text/template">

## 2.8. Inside Provider

***

### Нюансы передачи через Context

1. Компонент-провайдер должен **подписаться** на store,
   чтобы уведомлять консьюмеров
2. Писать каждый раз логику Wrapper неудобно,
   нужен **High Order Component**
3. Оборачиваемый компонент не зависит от всего состояния,
   значит надо **передавать только нужные части состояния**
4. Компонент-провайдер следит за всеми изменениями store,
   но оборачиваемые компоненты должны обновляться только
   **при изменениях используемых частей состояния**

_ Как это все-таки работает? _
_ Это точно работает быстро? _

***

### Простой Provider

```js
// Чистый React Context
function App({store}) {
  return (
    <Context.Provider value={store}>
      <RootComponent />
    </Context.Provider>
  );
}
// Как нам хотелось
function App({store}) {
  return (
    <Provider store={store}>
      <RootComponent />
    </Provider>
  );
}
```

Синтаксически подходит!
Но вспомним про необходимость подписки и сделаем обертку

***

### Подписка на обновление в Provider

```js
class Provider extends Component {
  constructor(props) {
    super(props);
    this.state = { storeState: props.store.getState(), store: props.store };
  } // storeState нужен, чтобы обновлять контекст при изменениях
  componentDidMount() {
    this.props.store.subscribe(() => {
      const storeState = this.props.store.getState();
      this.setState(state =>
	    state.storeState !== storeState ? storeState : null);
    });
  } // любое изменение store.getState() приводит к изменению state и контекста
  render() {
    return <Context.Provider value={this.state}>
             {this.props.children}</Context.Provider>;
  } // далее другие методы класса
```

***

### Желаемое использование HOC

```js
// Настройка связи со store
const withStore = connect(
  (state, props) => ({
    seconds: state.seconds
  }),
  (dispatch, props) => ({
    onChange: value => dispatch(changeSeconds(value))
  })
);

// Создание компонента
const ConnectedTimer = withStore(Timer);
```
`connect` — это High Order Function,
порождающая High Order Component

***

### Простой connect

```js
function connect(selectProps) {
  return function wrapWithConnect(WrappedComponent) {
    class Connect extends Component {
      renderWrappedComponent = contextValue => {
        const { storeState, store } = contextValue;	  
        const derivedProps = selectProps(storeState, this.props, store);
        return <WrappedComponent {...derivedProps} />;
      };
      render() {
        return <Context.Consumer>
          {this.renderWrappedComponent}</Context.Consumer>;
      }
    }
    return Connect;
  }
}
```

***

### Вопрос ребром

Как часто будет происходить рендеринг
WrappedComponent при простой реализации?

***

### Пример

<img width="600px" src="assets/set1.png">

***

### Обработка setState

<img width="600px" src="assets/set2.png">

***

### Обработка setState

<img width="600px" src="assets/set3.png">

***

### Защита благодаря PureComponent

<img width="600px" src="assets/set4.png">

***

### Обработка action

<img width="600px" src="assets/context1.png">

***

### Обработка action

<img width="600px" src="assets/context2.png">

***

### Защита благодаря selectProps

<img width="600px" src="assets/context3.png">

***

### Защита благодаря PureComponent

```js
function connect(selectProps) {
  return function wrapWithConnect(WrappedComponent) {
    class Connect extends PureComponent {
      renderWrappedComponent = contextValue => {
        const { storeState, store } = contextValue;	  
        const derivedProps = selectProps(storeState, this.props, store);
        return <WrappedComponent {...derivedProps} />;
      };
      render() {
        return <Context.Consumer>
          {this.renderWrappedComponent}</Context.Consumer>;
      }
    }
    return Connect;
  }
}
```

***

### Защита благодаря selectProps

```js
renderWrappedComponent = value => {
  const { storeState, store } = value;
  // selectProps пусть выбирает нужное из store, сохраняя результат
  const derivedProps = selectProps(storeState, this.props, store);
  return <WrappedComponent {...derivedProps} />;
};
```
При каждом обновлении `store`
вызывается `renderWrappedComponent`

Если `selectProps` будет запоминать значения `derivedProps`
и создавать новый объект `derivedProps` только при изменениях,
которые могут повлиять на `WrappedComponent`,
лишних перерисовок `WrappedComponent` не будет,
даже если `WrappedComponent` не pure

Так и сделано!

***

### Необходимое условие для selectProps

`selectProps` будет работать корректно
только при использовании immutable-обновлений

***

### connect()

```js
function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
  return function wrapWithConnect(WrappedComponent) {
    function makeDerivedPropsSelector() {
      return function selectDerivedProps(state, props, store) {
        // создается на основе mapStateToProps, mapDispatchToProps, mergeProps
      };
    }
    class Connect extends PureComponent {
      constructor(props) {
        super(props);
        this.selectProps = makeDerivedPropsSelector();
      } /* ... */
    }
    return Connect;
  };
}
```

***

### pure в connect()

```js
function connect(mapStateToProps, mapDispatchToProps, mergeProps,
  { pure = true, ...extraOptions } = {} // параметров даже больше
) {
  return function wrapWithConnect(WrappedComponent) {
    function makeDerivedPropsSelector() {
	  // зависит от pure
      return function selectDerivedProps(state, props, store) {/* ... */}
    }
    class Connect extends (pure ? PureComponent : Component) {
      /* ... */
    }
    return Connect;
  };
}
```

По умолчанию задана опция `pure`, а значит HOC будет создавать `PureComponent`, но этом можно изменить

***

### statics в connect()

```js
function connect(mapStateToProps, mapDispatchToProps, mergeProps,
  { pure = true, ...extraOptions } = {}
) {
  return function wrapWithConnect(WrappedComponent) {
    function makeDerivedPropsSelector() {
	  /* ... */
    }
    class Connect extends (pure ? PureComponent : Component) {
      /* ... */
    }
	// статические поля и функции из исходного компонента копируются в обертку
    return hoistNonReactStatics(Connect, WrappedComponent);
  };
}
```
Копирование статических полей позволяет использовать
результат `connect()` как исходный компонент

***

### Все параметры connect()

```js
connect(
  (state, props) => ({
    seconds: state.seconds
  }),
  (dispatch, props) => ({
    onChange: value => dispatch(changeSeconds(value))
  }),
  (stateProps, dispatchProps, ownProps) ({
    ...ownProps, ...stateProps, ...dispatchProps
  })
)(Timer);
```

Обычно задаются `mapStateToProps`, `mapDispatchToProps`

`mergeProps` по умолчанию действует так:
`{ ...ownProps, ...stateProps, ...dispatchProps }`
и обычно не переопределяется

***

### Задание 2.8. Cart

***

### Вопросы
1. С чего начали делать задачу? Что делали потом?
2. Как боролись с immutable-обновлениями?
3. Какие еще были сложности?

***

### Когда создавать контейнеры?

**Не следует делать из всех компонентов контейнеры!**

Часто достаточно создать **один контейнер на страницу**,
а дальше передавать данные и обработчики через props.

Также надо создавать контейнеры **для общих блоков**,
вроде меню или чата.

Например, для «страницы» `Cart` стоит создать контейнер,
а для «элемента на странице» `Purchase` — нет.

С другой стороны для `Product` на «странице» `Menu` ранее был
создан контейнер и при добавлении корзины его удобно использовать.

Поэтому полезно делать контейнеры для **компонентов,
активно взаимодействующих с другими частями приложения**.

</script></section>


<!-- ************************************************* -->


<section data-markdown><script type="text/template">

## 2.9. Cross Slice Reducer

***

### Действия на несколько слайсов

Есть действия, которые можно обработать,
только получив данные из нескольких слайсов,
либо обновив сразу несколько слайсов

Такие действия можно обработать с помощью подхода
*Cross Slice Reducer*

***

### Обработка действий в два шага

```js
const combinedReducer = combineReducers({
  a: sliceReducerA,
  b: sliceReducerB
});

function rootReducer(state, action) {
  const intermediateState = combinedReducer(state, action);
  const finalState = crossSliceReducer(intermediateState, action);
  return finalState;
}
```

Сначала отрабатывают редьюсеры для одиночных слайсов,
а затем при необходимости `crossSliceReducer` вносит изменения,
задевающие несколько слайсов

***

### Пример Cross Slice Reducer

```js
function crossSliceReducer(state, action) {
  switch (action.type) {
    case 'SOME_SPECIAL_ACTION': {
      return {
        // специально state.b передается как дополнительный аргумент
        a: handleSpecialCaseForA(state.a, action, state.b),
        b: sliceReducerB(state.b, action)
      };
    }
    default:
      return state;
  }
}
```

***

### Задание 2.9. Orders

***

### Выводы

Редьюсер не обязательно декомпозируется по слайсам.
Он может декомпозироваться по шагам.

</script></section>


<!-- ************************************************* -->


<section data-markdown><script type="text/template">

## Заключение

***

### Обратная связь
Заполни форму обратной связи по ссылке
<a href="http://bit.ly/kontur-courses-feedback">http://bit.ly/kontur-courses-feedback</a>

</script></section>
			
</div></div>
</body>
</html>
