В этом задании нужно добиться, чтобы меню реально фильтровалось. Строить список отфильтрованных блюд будем через API.
Для этого маленького приложения это избыточно: меню можно было отфильтровать прямо в браузере, но через API интереснее.

После предыдущего задания в `state` появился слайс `chosenProductsSlice` примерно такой структуры:
  ```typescript
  const state = {
    /* ... */
    chosenProducts = {
      tags: [ProductTag.hot, ProductTag.veg],
      ids: [1, 5],
      status: Status.loaded
    }
    /* ... */
  }
  ```

1. Сейчас меню всегда показывает полный список продуктов. Надо сделать так,
чтобы после успешной загрузки отфильтрованного списка продуктов, отображался он.
Для начала нужно изменить код так, чтобы компонент `Menu` умел получать данные из слайса `chosenProductsSlice`.

    Добавьте функции-селекторы `getProductStatus` и `getProductIds` в `features/products/productsSlice.ts`:
    ```typescript
    export function getProductStatus(state: RootState) {
      const {products, chosenProducts} = state;

      if (chosenProducts.status === Status.loading || products.status === Status.loading) {
        return Status.loading;
      }

      if (products.status === Status.loaded) {
        return Status.loaded;
      }

      return Status.none;
    }

    export function getProductIds(state: RootState) {
      const {products, chosenProducts} = state;

      if (chosenProducts.status === Status.loaded) {
        return chosenProducts.ids;
      }

      if (products.status === Status.loaded) {
        return products.allIds;
      }

      return [];
    }
    ```

    Измените компонент `Меню` так, чтобы он использовал функции-селекторы `getProductStatus` и `getProductIds`:
    ```typescript
    import {getProductIds, getProductStatus} from '../productsSlice';

    export const Menu = () => {
      const productIds = useAppSelector(getProductIds);
      const productsStatus = useAppSelector(getProductStatus);

      // ...
    };
    ```

2. Нужно сделать так, чтобы обновление галочек в фильтрах
приводило к вызову метода `api.fetchProductIdsByTags`, который вернет список продуктов в соответствие с фильтром.
Для этого можно изменить логику callback `handleChange` в компоненте `MenuFilter`
примерно так (**не спеши копировать этот код, он нерабочий**):
    ```typescript
    export const MenuFilter = () => {
      // ...

      const handleChange = (productTag) => {
        dispatch(changeProductTag(productTag));

        dispatch(loadByTagsRequest());
        api.fetchProductIdsByTags(tags).then(productIds => {
          dispatch(loadByTagsSuccess(productIds));
        });
      };

      // ...
    };
    ```
    У этого кода много проблем:
      - Опять нужно создавать несколько case редьюсеров для обработки асинхронного вызова `api.fetchProductIdsByTags`
      - Откуда взять `api`? Api создается на уровне приложения в `app/store.ts`
      - Чтобы вызвать `fetchProductIdsByTags` нужно передать все `chosenTags`,
      а не только `productTag`, текущее значение одной из галочек.
      - Приходится модифицировать компонент, чтобы изменить поведение приложения при переключении галочки.

    Осознай все эти проблемы, а затем переходи к следующему шагу.

3. Красивое решение описанных проблем — redux-thunk.
Это middleware, который позволяет передавать функции, порождающие действия, вместо действий.
Причем этим функциям доступны `getState` и `dispatch` и дополнительный аргумент.

    Но сначала нужно подключить `redux-thunk` `middleware`.
    Функция `configureStore` умеет подключать набор `middleware` по умолчанию. В этот набор входит `redux-thunk`.
    В поле `middleware` нужно передать callback функцию, которая получит функцию `getDefaultMiddleware` в
    качестве аргумента и должна вернуть массив `middleware`. Также `getDefaultMiddleware` позволяет сконфигурировать
   `middleware`:

    ```typescript
    export const store = configureStore({
      reducer,
      middleware: (getDefaultMiddleware) =>
        getDefaultMiddleware({
          thunk: {
            extraArgument: {api},
          },
        }).concat(customMiddleWare, logger),
    });
    ```

4. Для создания thunk будем использовать функцию `createAsyncThunk` из `@reduxjs/toolkit`. Преимуществом `createAsyncThunk`
   является то, что это API позволяет автоматизировать создание действий для обработки начала, завершения и ошибки
   при асинхронных операциях.

    Импортируй `createAsyncThunk` из `@reduxjs/toolkit` в `features/chosenProducts/chosenProductsSlice.ts`:
    Добавь реализацию `filterProductsByTag`:
    ```typescript
    export const filterProductsByTag = createAsyncThunk<
      // Возвращаемый тип createAsyncThunk
      number[],
      // Тип для первого агрумента createAsyncThunk
      number,
      {
        // Опциональные поля для определения типов полей thunkApi
        dispatch: AppDispatch;
        state: RootState;
        extra: {
          api: Api;
        };
      }
    >('chosenProducts/createAsyncThunk', (tag, thunkAPI) => {
      // Напиши реализацию filterProductsByTag
    });
    ```
    В `filterProductsByTag` доступно все необходимое, чтобы сделать запрос к API.

    Напиши реализацию так, чтобы `filterProductsByTag` выполнял последовательно следующее:
      - через `dispatch` вызывал действие `createAsyncThunk`, чтобы переключить чекбокс в фильтре
      - производил загрузку через `api` и вернуть `Promise`

    Код неудачной версии компонента `MenuFilter` удобно взять за основу `filterProductsByTag`.
    Используй `filterProductsByTag` вместо `changeProductTag` в компоненте `MenuFilter`.

5. Начиная с RTK 1.9 можно определить предварительно типизированную версию `createAsyncThunk`, в которой можно задать типы для `state`, `dispatch` и `extra`.
Это позволяет избавиться от необходимости задавать типы каждый раз при вызове `createAsyncThunk`

    Для создания предварительно типизированной версии `createAsyncThunk`, используй `createAsyncThunk.withTypes<>()` и передай объект, содержащий
    имена и типы полей для `state`, `dispatch` и `extra`:
    ```typescript
    const createAppAsyncThunk = createAsyncThunk.withTypes<{
      dispatch: AppDispatch;
      state: RootState;
      extra: {
        api: Api;
      };
    }>();
    ```

    Размести создание `createAppAsyncThunk` в отдельном файле `app/createAppAsyncThunk.ts` и используй `createAppAsyncThunk`
    вместо `createAsyncThunk` в `features/chosenProducts/chosenProductsSlice.ts`:
    ```typescript
    export const filterProductsByTag = createAppAsyncThunk<number[], number>(
      'chosenProducts/createAsyncThunk',
      (tag, thunkAPI) => {
        // Реализация filterProductsByTag
      }
    );
    ```

6. Теперь добавь обработку действия "pending" и "fulfilled".
   Эти создатели действий заданы в `filterProductsByTag` в качестве вложенных полей, и мы можем передать их в extraReducers:
    ```typescript
    const chosenProductsSlice = createSlice({
      name: 'chosenProducts',
      initialState,
      reducers: {
        changeProductTag(state, {payload: productTag}: PayloadAction<number>) {
          // Реализация changeProductTag
        },
      },
      extraReducers(builder) {
        builder
          .addCase(filterProductsByTag.pending, (state) => {
            state.status = Status.loading;
          })
          .addCase(filterProductsByTag.fulfilled, (state, {payload: productIds}) => {
            state.ids = productIds;
            state.status = Status.loaded;
          })
          .addCase(filterProductsByTag.rejected, (state) => {
            state.ids = [];
            state.tags = [];
            state.status = Status.none;
          });
      },
    });
    ```

    Убедись, что фильтры полностью работают.

6. Запросы к API могут заканчиваться ошибками и их надо обрабатывать.
Чтобы просимулировать это замени вызов `fetchProductIdsByTags` на `fetchProductIdsByTagsUnstable`.
Нестабильный метод API падает в половине случаев.
Теперь, если несколько раз переключить фильтр, появится ошибка в консоли и бесконечный лоадер.
`createAsyncThunk` умеет генерировать создатель действия `filterProductsByTag.rejected`. Добавь его в `extraReducers`.
Сделай так, чтобы в случае ошибки исчезал лоадер и все чекбоксы фильтров сбрасывались.
