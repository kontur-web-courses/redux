Перед тобой собранный из React-компонентов интернет-магазин суши.
Правда в нем не прописана логика поведения.

В этом задании нужно сделать так, чтобы заработало переключение страниц.

В `app/store.ts` уже создается `store` с некоторым начальным состоянием:
`const store = createStore(rootReducer, preloadedState);`.

Выше можно заметить, что на тип для стейта `RootState` извлекается из rootReducer:
`type RootState = ReturnType<typeof rootReducer>;`
Это пригодится позже.

На данном этапе `store` никак не связан с React-компонентами. Эту связь надо установить:
1. Добавь `Provider` из `react-redux` в компонент `App` из `App.tsx`.
Модуль `react-redux` уже установлен, но не импортирован.

    Пример создания провайдера:
    ```typescript jsx
    import { Provider } from 'react-redux';

    function App({store}) {
      return (
        <Provider store={store}>
          <RootComponent />
        </Provider>
      );
    }
    ```

2. Сделай так, чтобы компоненты `Navigation.tsx` и `Pages.tsx` взаимодействовали со store.
Для получения данных из store используй хук `useSelector`.
Компонент `Navigation` должен и подсвечивать текущую страницу.
Компонент `Pages` должен отображать текущую страницу.

    Пример использования `useSelector`:
    ```typescript jsx
    import * as React from "react";
    import { useSelector } from "react-redux";
    import { changeSeconds } from "../actionCreators";
    import type { RootState } from './store';

    export const Timer: React.FC = () => {
      const state = useSelector((state: RootState) => state.seconds);

      return (
        <div className="app">
          <Timer
            seconds={seconds}
          />
        </div>
      );
    };
    ```

    Не забудь убрать передачу ненужных props в `Navigation.tsx` и `Pages.tsx` и почистить интерфейсы.

3. На предыдущем шаге для получения данных из store использовался хук `useSelector`.
Поскольку `useSelector` никак не связан с `RootState` приложения, для типизации селектора
приходится прописывать тип `state` явно:
`const page = useSelector((state: RootState) => state.page);`

    Для того чтобы иметь типизированный `useSelector`, не импортировать `RootState` в каждый
    компонент и не прописывать тип явно, можно определить типизированные версии хуков и положить
    их в отдельный файл. В этом проекте все нужные хуки уже созданы в `app/hooks.ts`

    Замени в `Navigation.tsx` и `Pages.tsx` `useSelector` на `useAppSelector` из `app/hooks.ts`.

    Теперь компоненты `Navigation.tsx` и `Pages.tsx` берут данные из `store`.
    В этом можно убедиться, изменив дефолтное значение `page` в `defaultState` из `app/store.ts`.
    Однако при клике на элементы навигации ничего не происходит.
    Необходимо еще написать обработку события переключения страницы.

4. В `features/index.ts` находится код `rootReducer`. Он пока не обрабатывает действия,
а только возвращает текущее значение `state`.

    В `features/index.ts` создай константу `NAVIGATE_TO_PAGE`.
    ```typescript
    const NAVIGATE_TO_PAGE = 'NAVIGATE_TO_PAGE' as const;
    ```

    Далее добавь action creator:
    ```typescript
    export const navigateTo = (page: Page) => ({
      type: NAVIGATE_TO_PAGE,
      page
    });
    ```
    Action creator принимает целевую страницу `page` и создает экшен с типом `NAVIGATE_TO_PAGE`.

5. Чтобы типизировать action, исправь тип `type ActionTypes = unknown`.
Теперь его можно вывести из `navigateTo`:
    ```typescript
    type ActionTypes = ReturnType<typeof navigateTo>;
    ```

6. Добавь обработку действия с типом `NAVIGATE_TO_PAGE` в `rootReducer`.

    Редьюсер всегда должен возвращать актуальный `state`, поэтому для действия с типом `NAVIGATE_TO_PAGE` он должен
    вернуть новый `state` с актуальной целевой страницей `page`.
    ```typescript
    export function rootReducer(state = defaultState, action: ActionTypes) {
      switch (action.type) {
        case NAVIGATE_TO_PAGE:
          return {
            ...state,
            page: action.page
          };
      }
      return state;
    }
    ```
    Конструкция `switch` используется для того, чтобы проще было добавлять новые экшены.

7. Осталось вызвать действие переключение станицы `navigateTo()` через `dispatch` из компонента `Navigation.js`.
Для получения `dispatch` в функциональном компоненте используется хук `useDispatch`. В данном
приложении необходимо использовать типизированный хук `useAppDispatch` из `app/hooks.ts`

    Пример использования `useSelector` и `useDispatch` в одном компоненте:
    ```typescript jsx
    import * as React from "react";
    import { useSelector, useDispatch } from "react-redux";
    import { changeSeconds } from "../actionCreators";

    export const Timer = () => {
      const state = useSelector((state) => state.seconds);
      const dispatch = useDispatch();

      const handleDecrease = () => {
        dispatch(changeSeconds(-1));
      };

      const handleIncrease = () => {
        dispatch(changeSeconds(1));
      };

      return (
        <div className="app">
          <Timer
            seconds={seconds}
            onDecrease={handleDecrease}
            onIncrease={handleIncrease}
          />
        </div>
      );
    };
    ```

    Если все сделано правильно, то при клике на элементы навигации, страницы будут переключаться.
